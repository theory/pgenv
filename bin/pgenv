#!/usr/bin/env bash
#
# VERSION
#
PGENV_VERSION="1.3.8"

# https://stackoverflow.com/a/19622569/79202
trap 'exit' ERR
set -E

# Set PGENV_ROOT only if not already set.
if [ -z "$PGENV_ROOT" ]; then
    PGENV_ROOT=$(dirname $(dirname $0))
else
    echo "Using PGENV_ROOT $PGENV_ROOT" >&2
fi

cd $PGENV_ROOT
# Always use an absolute path or configure could complain.
PGENV_ROOT=$(pwd)

# configuration file location
PGENV_CONFIG_ROOT=${PGENV_ROOT}/config

PGSQL=$PGENV_ROOT/pgsql
PG_DATA=$PGSQL/data
PGENV_DOWNLOAD_ROOT='https://ftp.postgresql.org/pub/source/'

# Now -w because 9.0 and earlier always time out even when successful.
PG_CTL="$PGSQL/bin/pg_ctl"
INITDB="$PGSQL/bin/initdb"

#############################################
# Configuration variable and default settings

PGENV_LOG=$PG_DATA/server.log
PGENV_MAKE_OPTIONS=(-j3)
PGENV_CONFIGURE_OPTIONS=()
PGENV_INITDB_OPTIONS=(-U postgres --locale en_US.UTF-8 --encoding UNICODE)
PGENV_START_OPTIONS=()
PGENV_STOP_OPTIONS=()
PGENV_RESTART_OPTIONS=()

#############################################

# Prints a debug message if PGENV_DEBUG
# variable enabled
pgenv_debug(){
    if [ ! -z "$PGENV_DEBUG" ]; then
        echo "[DEBUG] $@" >&2
    fi
}

# This function connects to the PostgreSQL web site
# (i.e., PGENV_DOWNLOAD_ROOT) and gets the list of
# available versions.
# The function populates the global hash array
# pg_versions_hash, that is indexed by the version major number
# multiplied by 10 (e.g., 13 -> 130) and contains a list
# of versions separated by a dash (e.g., 13.0-13.1)
pgenv_get_downloadable_versions(){
    local version
    local major
    local minor

    if [ -z "$PGENV_SED" ]; then
        PGENV_SED=$(command -v sed)
    fi


    # First of all download the page with the links to each version (href=va.b.c/)
    # and trim out each version, then extract the major version
    # and append each version to an hash indexed by the major version number
    pgenv_debug "Get downloadable version from $PGENV_DOWNLOAD_ROOT"
    for version in $( curl -s $PGENV_DOWNLOAD_ROOT \
                          | grep -o '<a href=['"'"'"][^"'"'"']*['"'"'"]' \
                          | sed -e 's/^<a href=["'"'"']//' -e 's/["'"'"']$//' \
                          | sed 's/^v//' \
                          | sed 's/\/$//')
    do
        # skip FTP directories
        if [ "$version" = ".." ]; then
            continue
        fi


        major=$( echo $version | $PGENV_SED 's/\([[:digit:]]\{1,2\}\).*/\1/' )
        pgenv_debug "Extracted major version [$major]"


	# skip versions 6.x and 1.x because the
	# tarballs have different names and probably they will
	# not build
	if [ $major -le 6 ]; then
	    pgenv_debug "Skipping too old version $major"
	    continue
	fi

        # check the version is a number!
        if [[ $major =~ ^[0-9]+$ ]] ; then
            # Since PostgreSQL 10, a major version is
            # made by only the first number
            # here the major version is considered as multipled
            # by a ten factor, so that version 10 becomes value 100
            # while version 9.6 becomes 96
            if [ $major -ge 10  ]; then
                minor=0
            else
                minor=$( echo $version | $PGENV_SED 's/[[:digit:]]\.\([[:digit:]]\{1,2\}\).*/\1/' )
            fi
            major=$(( major * 10 + minor ))
            pgenv_debug "Normalized major version [$major]"
            # append the current version to the hash
            # indexed by the major version
            pg_versions_hash[ "$major" ]+="${version}-"
        fi
    done

}

pgenv_versions() {
    if [ -e "pgsql" ]; then
        local curr=$(readlink pgsql)
    fi
    local installed=0
    local flags=""
    for dir in $( ls -d pgsql-* 2>/dev/null); do
        if [ "$dir" = "$curr" ]; then
            flags="  *"
        else
            flags="   "
        fi

        if [ -z "$PGENV_SED" ]; then
            PGENV_SED=$(command -v sed)
        fi
        local version=$( echo $dir | $PGENV_SED 's/^pgsql-//' )
        printf "%s   %-6s    %s\n" "$flags" "$version" "$dir"
        installed=$(( installed + 1 ))
    done

    if [ $installed -eq 0 ]; then
        echo "No PostgreSQL version is installed!"
    fi
}

pgenv_help() {

    # get current git version if possible
    if [ ! -z "$( command -v git )" -a -d "${PGENV_ROOT}/.git" ]; then
        git_version="[$( git -c log.showSignature=false log -n 1 --format='%h' )]"
    fi

    cat <<EOF
Usage: pgenv <command> [<args>]

The pgenv commands are:
    use        Set and start the current PostgreSQL version
    start      Start the current PostgreSQL server
    stop       Stop the current PostgreSQL server
    restart    Restart the current PostgreSQL server
    status     Show the current PostgreSQL server status
    switch     Set the current PostgreSQL version
    clear      Stop and unset the current PostgreSQL version
    build      Build a specific version of PostgreSQL
    rebuild    Re-build a specific version of PostgreSQL
    remove     Remove a specific version of PostgreSQL
    version    Show the current PostgreSQL version
    current    Same as 'version'
    versions   List all PostgreSQL versions available to pgenv
    help       Show this usage statement and command summary
    available  Show which versions can be downloaded
    check      Check all program dependencies
    config     View, edit, delete the program configuration
    log        Inspects the log of the cluster, if exist.

For full documentation, see: https://github.com/theory/pgenv#readme

This is 'pgenv' version $PGENV_VERSION $git_version
EOF
}

# Searches for all dependencies and prints a report. If the argument is null,
# only missing depencencies will be reported. Otherwise, it prints the paths for
# all commands.
pgenv_check_dependencies(){
    local verbose=$1
    # Don't exit on error.
    trap "" ERR

    local present=""
    local missing=""
    local warning=""

    pgenv_detail_command(){
        local command_name=$1
        local command=$2

        local nl=$'\n'
        local tab=$'\t'
        if [ -z "$command" ]; then
                missing+="[ERROR] $command_name:${tab}required but NOT found!$nl"
        else
            present+="[FOUND] $command_name:$tab$command$nl"
        fi
    }

    if [ -z "$PGENV_MAKE" ]; then
        PGENV_MAKE=$(command -v make)
        if [ -z "$PGENV_MAKE" ]; then
            PGENV_MAKE=$(command -v gmake)
        fi
    fi
    pgenv_detail_command "make" $PGENV_MAKE

    if [ -z "$PGENV_CURL" ]; then
        PGENV_CURL=$(command -v curl)
    fi
    pgenv_detail_command "curl" $PGENV_CURL

    if [ -z "$PGENV_PATCH" ]; then
        PGENV_PATCH=$(command -v patch)
    fi
    pgenv_detail_command "patch" $PGENV_PATCH

    if [ -z "$PGENV_TAR" ]; then
        PGENV_TAR=$(command -v tar)
    fi
    pgenv_detail_command "tar" $PGENV_TAR

    if [ -z "$PGENV_SED" ]; then
        PGENV_SED=$(command -v sed)
    fi
    pgenv_detail_command "sed" $PGENV_SED

    # check for sort and tr and tail, but not place into
    # variables (do we need to push to that extent?)
    pgenv_detail_command "sort" $(command -v sort)
    pgenv_detail_command "tr" $(command -v tr)
    pgenv_detail_command "tail" $(command -v tail)

    # Go back to exiting on error.
    trap 'exit' ERR
    if [ ! -z "$verbose" ]; then
        # Report found dependencies only in verbose mode.
        echo -n "$present"
    fi
    if [ ! -z "$warning" ]; then
        # Always show warnings.
        echo -n "$warning"
    fi
    if [ ! -z "$missing" ]; then
        # Always show missing dependencies and exit with an error.
        echo "$missing"
        exit 1
    fi
}

# This function provides the specified version from an alias name.
# WARNING: this does not include beta versions!!!
#
# Accepted parameters are either 'latest' or 'earliest' to select
# the latest stable version installed or the oldest one.
# If the option second argument is specified, it must be a "filter"
# to the version to search for, usually the major version number.
# So for example passing '9.6' as second argument will restrict
# the search into all the installed '9.6.x' versions.
pgenv_find_version_on_disk(){
    local search_for=$1
    local filter=$2
    local brand
    local year
    local selected
    local patch
    local current_version
    local selected_value

    # find sed even without the configuration/dependencies
    if [ -z "$PGENV_SED" ]; then
        PGENV_SED=$(command -v sed)
    fi

    for version in $( ls -d pgsql-${filter}* 2>/dev/null | $PGENV_SED 's/pgsql-//' ); do
        # skip beta versions
        if [[ $version =~ ^[1-9][1-9](beta|rc)[1-9]?$ ]]; then
            continue
        fi

        pgenv_debug "Version $version"
        brand=$( echo $version | $PGENV_SED 's/\([[:digit:]]\{1,2\}\).*/\1/' )
        year=$(  echo $version | $PGENV_SED 's/[[:digit:]]\{1,2\}\.\([[:digit:]]\{1,2\}\).*/\1/' )
        patch=$( echo $version | $PGENV_SED 's/[[:digit:]]\{1,2\}\.[[:digit:]]\{1,2\}\.\{0,1\}\([[:digit:]]\{0,2\}\).*/\1/' )

        # to avoid that version less than 10 confuses the match, let's
        # multiply the brand version by 1000
        current_version=$(( ( brand * 1000 ) + ( year * 100 ) + patch ))
        pgenv_debug "Found version [$current_version]"

        case "$search_for" in
            latest)
                if [ -z "$selected_value" ] || [ $selected_value -lt $current_version ]; then
                    selected_value=$current_version
                    selected=$version
                fi
                ;;
            earliest)
                if [ -z "$selected_value" ] || [ $selected_value -gt $current_version ]; then
                    selected_value=$current_version
                    selected=$version
                fi
                ;;
        esac
    done

    pgenv_debug "Version selected for [$search_for $filter] = $selected"
    echo $selected
}

# Guesses the selected PostgreSQL version to use.
# The idea is that every time a command needs a PostgreSQL version number
# this function should be called.
# As an example:
# v=$( pgenv_guess_postgresql_version $2 )
#
# - with $2 = 13.0 will return it (13.0);
# - with $2 = "current" will return the current version in use (if any)
# - with $2 = "earliest" will return the oldest version installed
#
# In the case an optional second parameter is passed, it will be used
# as a filter for 'latest' and 'earliest'. For example 'latest' '13'
# will search for the very latest version available between the '13.x' series.
pgenv_guess_postgresql_version() {
    local v=$1
    local filter=$2

    case "$v" in
        current|version)
            # current version is the one that has been selected by `use`
            v=$( pgenv_current_postgresql_version )
            ;;
        default)
            # there is no default version, this is useful only
            # for specifying the 'default configuration'
            v="default"
            ;;
        latest|earliest)
            # must guess!
            v=$( pgenv_find_version_on_disk "$v" "$filter" )
    esac

    pgenv_debug "Guessed PostgreSQL version is [$v]"
    echo "$v"
}

# This function checks if its first argument is a valid PostgreSQL version
# number, like "10.5" or "9.5.4". In case no version number is specified, or the
# version number is invalid (e.g., "10", "0.9") the function aborts the script.
# If no version has been specified, and a non-empty string is passed as second
# argument, the function prints out a list of installed versions.
#
# Invoking with `pgenv_input_version_or_exit "$v" "verbose"` will produce a list
# from which the user can choose, while `pgenv_input_version_or_exit "$v"`` will
# not. Mind the quotes!
#
# Invoking with a fourth non-empty parameter will allow the function to succeed
# in the case an "externally managed" version is found. An externally managed version
# is something that is do not represent a PostgreSQL version number (e.g, a git
# commit hash or branch) and does exist on the disk (i.e., there is a directory
# named `pgsql-` followed by the version string). This is called "externally
# managed" because the directory could have been created by something else (e.g.,
# a git checkout).
# As an example:
#        pgenv_input_version_or_exit "fluca" "verbose" '' "on-disk"
# will search for a directory named 'pgenv-fluca', and if exists, will not
# abort the script.
pgenv_input_version_or_exit() {
    local version=$1
    local verbose=$2
    local hint=$3
    local on_disk=$4

    if [ -z "$PGENV_SED" ]; then
        PGENV_SED=$(command -v sed)
    fi


    if [ -z "$version" ]; then
        if [ ! -z "$hint" ]; then
            # count the versions
            local installed_versions=0
            for installed in $( ls -d pgsql-* 2>/dev/null )
            do
                installed_versions=$(( installed_versions + 1 ))
            done
        else
            # make a fake value to use the following the if statement
            installed_versions=-1
        fi

        # if no version is installed, suggest the user to build one
        if [ $installed_versions -eq 0 ]; then
            echo "No PostgreSQL version is installed!"
            echo "Are you looking for command \`$hint\` instead?"
            exit 1
        else
            # at least one version is available,
            # ask more details to the user
            echo "Which version of PostgreSQL do you want?"
            if [ ! -z "$verbose" ]; then
                pgenv_versions
            fi
            exit 1
        fi
    fi


    if [[ $version =~ ^[1-9][0-9]?\.[0-9]+(\.[0-9]+)?$ ]]; then
	major=$( echo $version | $PGENV_SED 's/\([[:digit:]]\{1,2\}\).*/\1/' )
	pgenv_debug "Extracted major version [$major]"


	# skip versions 6.x and 1.x because the
	# tarballs have different names and probably they will
	# not build
	if [ $major -le 6 ]; then
	    pgenv_debug "Skipping too old version $major"
	    cat <<EOF
PostgreSQL version $version cannot be built or used via pgenv.
pgenv supports only PostgreSQL version 7.0 or greater.
EOF
	    exit 1
	fi

	# if here, all ok
        return # versions 9.5.4 or 10.1 and alike
    elif [[ $version =~ ^[1-9][1-9](beta|rc)[1-9]?$ ]]; then
        return # versions 11beta1 and alike
    elif [ ! -z "$on_disk" ]; then
	# the user specified something that is not an ordinary version, so check
	# for the existance on disk
	pgsql_dir="pgsql-$version"
	if [ ! -d "$pgsql_dir" ]; then
	    echo "No externally managed version $version found!"
	    exit 1
	else
	    pgenv_debug "Using externally managed version [$version] within [$pgsql_dir]"
	fi
    else
        echo "Value \"$version\" does not appear to be a PostgreSQL valid version"
        exit 1
    fi
}

# This function accepts a version number (that should have been already checked
# to be valid) and searches for an installation with such a version. If no
# installation with such version number has been found, the script aborts after
# showing installed versions
pgenv_installed_version_or_exit(){
    local version=$1
    if [ ! -e "pgsql-${version}" ]; then
        echo "PostgreSQL $version not installed; installed versions:"
        pgenv_versions
        exit 1
    fi
}

# Checks if there is a currently activer version and, if not, reports that fact
# and aborts the script.
pgenv_exit_if_no_postgresql_in_use(){
    if [ ! -e "pgsql" ]; then
        cat <<EOF >&2
No version of PostgreSQL currently in use!
To use a specific version run
    pgenv use <version>
To start immediately a specific version run
    pgenv start <version>
To see all locally installed clusters run
    pgenv versions

EOF
        exit 1
    fi
}

# Prints the currently active version number. To capture the value instead of
# printing it, make a call like `v=&( pgenv_current_postgresql_version )`
pgenv_current_postgresql_version(){
    # find sed even without the configuration/dependencies
    if [ -z "$PGENV_SED" ]; then
        PGENV_SED=$(command -v sed)
    fi
    local v=$( readlink pgsql | $PGENV_SED 's/^pgsql-//' )
    echo $v
}

# Provides the configuration file name
# for the specified version.
#
# If no version is specified, the default configuration
# file is provided.
#
# If the user has defined an environment variable named
#       PGENV_CONFIGURATION_FILE
# the function returns such name. This allows the user
# to use always a well established configuration file.
# It is possible to avoid the usage of the PGENV_CONFIGURATION_FILE
# environment variable if the second argument is something not null.
pgenv_configuration_file_name(){
    local v=$1
    local skip_env=$2
    local PGENV_DEFAULT_CONFIG_FILE="${PGENV_CONFIG_ROOT}/default.conf"


    # if the user has defined an environment variable PGENV_CONFIGURATION_FILE
    # I need to use that instead of trying to understand which file to use
    if [ ! -z "$PGENV_CONFIGURATION_FILE" -a -z "$skip_env" ]; then
	pgenv_debug "Configuration file forced by environment variable PGENV_CONFIGURATION_FILE = $PGENV_CONFIGURATION_FILE"
	echo "${PGENV_CONFIGURATION_FILE}"
	return
    fi


    if [ ! -z "$v" ]; then
        echo "${PGENV_CONFIG_ROOT}/$v.conf"
    else
        echo "${PGENV_DEFAULT_CONFIG_FILE}"
    fi
}

# Dumps the specified configuration file (if exists) or aborts.
#
# The function accept two option arguments:
# - the version number (if not specified the default configuration will be considered)
# - a title to use for printing the configruation file
#
# If the file cannot be found the function exits.
pgenv_configuration_dump_or_exit(){
    local v=$1
    local title=$2

    local CONF=$( pgenv_configuration_file_name $v )

    if [ -r $CONF ]; then

        echo "# $title"
        echo "# pgenv configuration for PostgreSQL $v"
        echo "# File: $CONF"
        echo "# ---------------------------------------------------"
        cat $CONF
        echo
    else
        echo "No configuration found for version <$title> [$CONF]" >&2
        exit 1
    fi
}

# Function to load the configuration from a file.
# A configuration file is a shell file that contains variables that
# will be 'sourced' into the current script runtime.
#
# The function accepts an optional argument which is the version number
# to search for. A configuration file with such version number
# will be used as configuration, and in the case it is missing, the default
# configuration file will be used.
#
# The function sets the PGENV_CONFIGURATION_FILE variable to the name of the
# file loaded or to an empty string. This helps understanding later on
# if the configuration has been loaded.
pgenv_configuration_load(){
    local v=$1

    local PGENV_DEFAULT_CONFIG_FILE=$( pgenv_configuration_file_name )
    local PGENV_CONFIG_FILE=$( pgenv_configuration_file_name $v )
    PGENV_CONFIGURATION_FILE=''

    for conf in $( echo "$PGENV_CONFIG_FILE" "$PGENV_DEFAULT_CONFIG_FILE" )
    do
        pgenv_debug "Looking for configuration in $conf"

        if [ -r "$conf" ]; then
            pgenv_debug "Load configuration from [$conf]"
            source "$conf"
            PGENV_CONFIGURATION_FILE="$conf"
            pgenv_merge_arrays
            return
        fi
    done

    pgenv_debug "No configuration loaded"
    PGENV_WARNINGS=true  # for backward compatibility
}

# Function to merge older string-based configuration variables into their array
# replacements. Arrays are the preferred way to configure options, since they're
# better at paramter passing, but we need to support older configurations that
# used string variables.
pgenv_merge_arrays() {
    if [ ! -z ${PGENV_INITDB_OPTS+x} ]; then
        PGENV_INITDB_OPTIONS=($PGENV_INITDB_OPTS)
    fi
    if [ ! -z ${PGENV_MAKE_OPTS+x} ]; then
        PGENV_MAKE_OPTIONS=($PGENV_MAKE_OPTS)
    fi
    if [ ! -z ${PGENV_CONFIGURE_OPTS+x} ]; then
        PGENV_CONFIGURE_OPTIONS=($PGENV_CONFIGURE_OPTS)
    fi
    if [ ! -z ${PGENV_START_OPTS+x} ]; then
        PGENV_START_OPTIONS=($PGENV_START_OPTS)
    fi
    if [ ! -z ${PGENV_STOP_OPTS+x} ]; then
        PGENV_STOP_OPTIONS=($PGENV_STOP_OPTS)
    fi
    if [ ! -z ${PGENV_RESTART_OPTS+x} ]; then
        PGENV_RESTART_OPTIONS=($PGENV_RESTART_OPTS)
    fi
}

# Utility function to remove the configuration file.
# It does remove the default file only if there are no more installed instances
# on this system.
pgenv_configuration_delete(){
    local v=$1
    local nuke=$2
    local PGENV_DEFAULT_CONFIG_FILE=$( pgenv_configuration_file_name )
    local PGENV_CONFIG_FILE=$( pgenv_configuration_file_name $v )

    pgenv_debug "\`config delete\` for version [$v] (nuke [$nuke])"

    # if the file is the default one, delete only if there are
    # no installed instances and the version has been explicitly
    # indicated by the user
    if [ "$PGENV_CONFIG_FILE" = "$PGENV_DEFAULT_CONFIG_FILE" ]; then
        if [ -z "$nuke" ]; then
            cat <<EOF >&2
No specific version specified, automatically selected the "default" one.
To delete the default configuration file in
   $PGENV_DEFAULT_CONFIG_FILE
you need to run the \`config delete default\` command explicitly.
EOF
            exit 1
        fi
        local installed_versions=0
        for installed in $( ls -d pgsql-* 2>/dev/null )
        do
            installed_versions=$(( installed_versions + 1 ))
        done

        if [ $installed_versions -gt 0 ]; then
            cat <<EOF >&2
Cannot delete default configuration file while PostgreSQL versions exists:
the file could be shared among such installations.
If you really want to delete the default configuration file
execute a command like
   rm $PGENV_CONFIG_FILE
EOF
            exit 1
        fi
        # if the file is not here, nothing to do!
      elif [ ! -f "$PGENV_CONFIG_FILE" ]; then
            echo "No configuration file to delete for version $v"
            exit 1
    fi

    # remove the file
    pgenv_debug "Deleting configuration file [$PGENV_CONFIG_FILE]"
    rm -f "$PGENV_CONFIG_FILE"            # remove config file
    rm -f ${PGENV_CONFIG_FILE}*.backup    # remove also backup file
    echo "Configuration file $PGENV_CONFIG_FILE (and backup) deleted"
}


# Utility function to print on stdout
# the path to which the program will look for a
# configuration file.
#
# This can be useful to exdport the environment variable
# to point to a custom path, like this:
#
#    % export PGENV_CONFIGURATION_FILE=$( pgenv config path 16neta2 )
#
# that will result in setting the PGENV_CONFIGURATION_FILE
# so that following usage of `pgenv` will use such a configuration
# file.
pgenv_configuration_show_path(){
    local v=$1
    echo $( pgenv_configuration_file_name "$v" "SKIP-ENV" )
}

# Utility function to write a single variable in the configuration file.
#
# Accepts:
# - the configuration file name to which write to
# - the name of the variable
# - the value of the variable
# - an optional comment.
#
#
# Invoking it as
#   pgenv_configuration_write_variable 'pgenv.conf' 'foo' 'bar' 'A foo option'
#
# will result in the file in the following:
#
#   # A foo option
#   foo=bar
#
# If the variable value is not set, the variable name is placed with a comment sign.
pgenv_configuration_write_variable(){
    local file=$1
    local name=$2
    local value=$3
    local comment=$4

    if [ ! -z "comment" ]; then
        echo "# $comment" >> "$file"
    fi


    if [[ "$name" =~ _OPTIONS$ ]]; then
        # using `declare` will make the variable `local`
        # once it is read from the pgenv_configuration_read function
        # so don't use it and export as a global variable
        declare -p "${name}" | sed 's/^declare -ax\? //' >> "$file"
        echo "export ${name}"  >> "$file"
    else
        # if no value supplied, put a comment
        if [ -z "$value" ]; then
            echo -n "#" >> "$file"
        fi
        echo "export ${name}='${value}'" >> "$file"
    fi
    echo >> "$file"
}

# Writes the whole current configuration to the current version file
# or the version file specified. It does a backup copy in the case
# the file already exists.
#
# If the environment variable PGENV_WRITE_CONFIGURATION_FILE_AUTOMATICALLY
# is set to a non-empty, non-zero value, the configuration file
# will be overwritten. In the case the variable is not set at all
# the application will apply the backward compatible behavior, so
# not setting the PGENV_CONFIGURATION_FILE_AUTOMATICALLY is like
# setting it to "YES".
pgenv_configuration_write() {
    local v=$1
    CONF=$( pgenv_configuration_file_name $v )

    # sanity check
    if [ -z "$CONF" ]; then
        echo "Cannot determine which configuration file to use!" > 2
        exit 1
    fi


    # check if we need to write the configuration file automatically:
    # if the variable is not set, assume the user wants the backward
    # compatible behavior: write the configuration file automatically
    if [ -z "$PGENV_WRITE_CONFIGURATION_FILE_AUTOMATICALLY" ]; then
	PGENV_WRITE_CONFIGURATION_FILE_AUTOMATICALLY="YES"
    fi

    # in the case the variable is set to a non-yes value, avoid overwriting
    case "$PGENV_WRITE_CONFIGURATION_FILE_AUTOMATICALLY" in
	0|[nN][oO])
	pgenv_debug "Not writing config file automatically: set \`PGENV_WRITE_CONFIGURATION_FILE_AUTOMATICALLY\` to a true value to enable the automatic file writing"
	return
	;;
    esac

    # check the configuration directory exists
    if [ ! -d "$PGENV_CONFIG_ROOT" ]; then
        mkdir -p "$PGENV_CONFIG_ROOT"
    fi

    # make a backup copy
    if [ -f "$CONF" ]; then
        CONF_BACKUP="${CONF}.$(date +'%Y-%m-%dT%H-%M').backup"
        pgenv_debug "Making backup copy of [$CONF] into [$CONF_BACKUP]"
        mv "$CONF" "$CONF_BACKUP"
    fi

    # ok, write the configuration
    echo "# pgenv configuration created on $(date)" > "$CONF"
    echo "" >> "$CONF"
    pgenv_configuration_write_variable "$CONF" "PGENV_DEBUG" "$PGENV_DEBUG" 'Enables debug output'
    pgenv_configuration_write_variable "$CONF" "PGENV_WARNINGS" "$PGENV_WARNINGS" 'Enables warning messages'

    echo "###### Build settings #####" >> "$CONF"
    pgenv_configuration_write_variable "$CONF" "PGENV_MAKE" "$PGENV_MAKE" 'Make command to use for build'
    pgenv_configuration_write_variable "$CONF" "PGENV_MAKE_OPTIONS" "" 'Make flags'
    pgenv_configuration_write_variable "$CONF" "PGENV_CONFIGURE_OPTIONS" "" 'Configure flags, including PL languages but without --prefix'

    pgenv_configuration_write_variable "$CONF" "PGENV_PATCH_INDEX" "$PGENV_PATCH_INDEX" 'A file that lists ordered patches to apply before building starts'

    pgenv_configuration_write_variable "$CONF" "PGENV_CURL" "$PGENV_CURL" 'Curl command to download source code'
    pgenv_configuration_write_variable "$CONF" "PGENV_PATCH" "$PGENV_PATCH" 'Patch command for specific versions'
    pgenv_configuration_write_variable "$CONF" "PGENV_SED" "$PGENV_SED" 'Sed used to manipulate strings'

    echo "##### Runtime options #####" >> "$CONF"
    pgenv_configuration_write_variable "$CONF" "PGENV_LOG" "$PGENV_LOG" 'Path to the cluster log file (mandatory)'
    pgenv_configuration_write_variable "$CONF" "PGENV_INITDB_OPTIONS" "" 'Initdb flags'
    pgenv_configuration_write_variable "$CONF" "PGENV_STOP_OPTIONS" "" 'Stop configuration flags'
    pgenv_configuration_write_variable "$CONF" "PGENV_START_OPTIONS" "" 'Start configuration flags'
    pgenv_configuration_write_variable "$CONF" "PGENV_RESTART_OPTIONS" "" 'Restart configuration flags'

    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_POSTINSTALL" "" 'Script to execute when the build process finishes'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_POSTINITDB" "" 'Script to execute when initdb finishes (and the server has not started yet)'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_FIRSTSTART"   "" 'Script to execute at the very first start of the instance'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_PRESTOP" "" 'Script to execute before the cluster stops'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_POSTSTOP" "" 'Script to execute when the cluster has been stopped'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_POSTSTART" "" 'Script to execute when the cluster has been started'
    pgenv_configuration_write_variable "$CONF" "PGENV_SCRIPT_POSTRESTART" "" 'Script to execute when the cluster has been restarted'

    echo "pgenv configuration written to file $CONF"
}

# Tests and warn the PATH environment variable.
# Prints out on STDERR a warning message, with an hint about
# how to fix it.
#
# If the configuration option PGENV_WARNINGS is not set, the function
# does not perform any check.
pgenv_warning_path(){
    if [ -z "$PGENV_WARNINGS" ]; then
        return
    fi

    local old_ifs=$IFS
    local path_ok=0
    local path_prepend=0
    local executables_wanted=0
    local executables="$PGENV_ROOT/pgsql/bin"

    # Test if pgsql is a link and not manually created
    # This should be a link only managed by this script
    if [ -e "$PGENV_ROOT/pgsql" ] && ! [ -h "$PGENV_ROOT/pgsql" ]; then
        cat <<EOF >&2

WARNING:
   Database working directory

        $PGENV_ROOT/pgsql

   should not be created manually.

HINT:
   Make a backup of it if this is an existing database
   directory and remove it, then let this script manage
   it automatically by building an instance of a PostgreSQL:

        pgenv build <version>

   and then using it:

        pgenv use <version>

EOF
    return
    fi

    IFS=':'

    # Test if PATH contains at least one entry
    # with the executables dir
    for p in $PATH
    do
        if [ "$p" -ef "$executables" ]; then
            path_ok=1
            break
        elif [ "$p" == "$executables" ]; then
            # PATH contains the entry
            # but the entry itself does not exist,
            # so no PostgreSQL instances are in use.
            # By the time an instance comes in use
            # everything should be fine, so ignore this.
            return
        fi
    done

    IFS=$old_ifs

    if [ $path_ok != 1 ]; then
        cat <<EOF >&2

WARNING:
  Your PATH enrvironemnt variable does not seem to include

       $executables

  as an entry. You will not be able to use the currently
  selected PostgreSQL binaries.

HINT:
  Adjust your PATH variable to include

  $executables

  for instance

  export PATH=$executables:\$PATH

EOF
        return
    fi

    # check that the PGENV path is ahead of other PostgreSQL binaries
    # in order to do so count a few common executables and see
    # if they are the same path as what is expected to be
    for cmd in psql pg_ctl pg_config
    do
        executables_wanted=$(( executables_wanted + 1))
        executable_searched_for=$( which $cmd )
        if [ "$executable_searched_for" -ef "$executables/$cmd" ]; then
            path_prepend=$(( path_prepend + 1 ))
        fi
    done

    if [ $executables_wanted -ne $path_prepend ]; then
        cat <<EOF >&2

WARNING:
   Your PATH environment variable has some PostgreSQL executable
   preprended to the currently in-use instance, so you may
   end up using the wrong executables against the selected cluster.

HINT:
   Prepend the following PATH entry in your environment setting

   $executables

   for instance

   export PATH=$executables:\$PATH

EOF
    fi

}

# Wrapper function to start the current instance.
# If the instance is already running, nothing happens.
# If the instance does not have already a PG_DATA
# directory, it will be initdb-ed.
pgenv_start_instance(){
    trap "" ERR

    # if the instance is already running, do nothing
    if $PG_CTL status -D "$PG_DATA" &> /dev/null; then
        echo "PostgreSQL $v is already running"
        return
    fi

    # Init the database if needed.
    # the special variable PGENV_INITDB_DONE will be valued accordingly
    pgenv_initdb

    pgenv_debug "pg_ctl starting instance with flags [${PGENV_START_OPTIONS[@]}] log [$PGENV_LOG]"
    $PG_CTL start -D "$PG_DATA"  -l "$PGENV_LOG" "${PGENV_START_OPTIONS[@]}" &> /dev/null
    if [ $? -eq 0 ]; then
        echo "PostgreSQL $v started"
        echo "Logging to $PGENV_LOG"

	# if this is the first start, i.e., the start run
	# just after the initialization, execute
	# the appropriate custom script
	if [ $PGENV_INITDB_DONE -eq 1 ]; then
	    if [ ! -z "$PGENV_SCRIPT_FIRSTSTART" -a -x "$PGENV_SCRIPT_FIRSTSTART" ]; then
		cat <<EOF
This is the first time PostgreSQL $v is started,
executing the \`PGENV_SCRIPT_FIRSTSTART\` script
   "$PGENV_SCRIPT_FIRSTSTART"

EOF
		$PGENV_SCRIPT_FIRSTSTART "$PG_DATA"
	    fi
	fi


        # if there is a post-start script to run, run it
        if [ -x "$PGENV_SCRIPT_POSTSTART" ]; then
            echo "Running post-start script [$PGENV_SCRIPT_POSTSTART]"
            $PGENV_SCRIPT_POSTSTART "$PG_DATA"
        fi

    else

        echo -e "\nPostgreSQL $v NOT started, examine logs in $PGENV_LOG\n"
        local LOG_LINES=5
        echo "Following are the last $LOG_LINES lines of the log, as a quick hint:"
        tail -n $LOG_LINES "$PGENV_LOG"

    fi
    trap 'exit' ERR
}

# Initializes an instance if no data directory is found.
# Requires PG_DATA to be set.
# It is safe to call multiple times.
#
# The function cannot return a value, because it alredy outputs
# values on the stdout, so it sets a variable to indicate that this is
# a first initialization of the database.
pgenv_initdb(){
    if [ ! -d $PG_DATA ]; then
        pgenv_debug "initdb running with flags [${PGENV_INITDB_OPTIONS[@]}]"
        $INITDB -D "$PG_DATA" "${PGENV_INITDB_OPTIONS[@]}"

        # if there is a post-initdb script to run, run it
        if [ -x "$PGENV_SCRIPT_POSTINITDB" ]; then
            echo "Running post-initdb script [$PGENV_SCRIPT_POSTINITDB]"
            $PGENV_SCRIPT_POSTINITDB "$PG_DATA"
        fi

	export PGENV_INITDB_DONE=1
    else
        pgenv_debug "Directory $PG_DATA exists, not initdb-ing!"
	export PGENV_INITDB_DONE=0
    fi
}

# Wrapper function to stop or restart the current instance.
# Accepts an optional argument 'command' that specifies
# if 'stop' or 'restart' action need to be performed.
#
# It is required that the second argument to the function is the version
# number of the PostgreSQL server to stop. While this has nothing special
# with the behavior of the command, it is useful for displaying
# messages and find out the configuration.
pgenv_stop_or_restart_instance(){
    local command=$1
    local v=$2

    # Don't exit on error.
    trap "" ERR

    if $PG_CTL status -D "$PG_DATA"  &> /dev/null; then
        # ok, server running, apply the command
        case $command in
            stop)
                pgenv_debug "pg_ctl stopping with flags [${PGENV_STOP_OPTIONS[@]}]"

                # if there is a pre-stop script to run, run it
                if [ -x "$PGENV_SCRIPT_PRESTOP" ]; then
                    echo "Running pre-stop script [$PGENV_SCRIPT_PRESTOP]"
                    $PGENV_SCRIPT_PRESTOP "$PG_DATA"
                fi

                $PG_CTL stop -D "$PG_DATA" "${PGENV_STOP_OPTIONS[@]}" &> /dev/null
                echo "PostgreSQL $v stopped"

                # if there is a post-stop script to run, run it
                if [ -x "$PGENV_SCRIPT_POSTSTOP" ]; then
                    echo "Running post-stop script [$PGENV_SCRIPT_POSTSTOP]"
                    $PGENV_SCRIPT_POSTSTOP "$PG_DATA"
                fi
                ;;
            restart)
                pgenv_debug "pg_ctl restarting with flags [${PGENV_RESTART_OPTIONS[@]}]"
                $PG_CTL restart -D "$PG_DATA" -l "$PGENV_LOG" "${PGENV_RESTART_OPTIONS[@]}" &> /dev/null
                echo "PostgreSQL $v restarted"
                echo "Logging to $PGENV_LOG"

                # if there is a post-restart script to run, run it
                if [ -x "$PGENV_SCRIPT_POSTRESTART" ]; then
                    echo "Running post-restart script [$PGENV_SCRIPT_POSTRESTART]"
                    $PGENV_SCRIPT_POSTRESTART "$PG_DATA"
                fi
                ;;
        esac
    else
        # server not running
        case $command in
            stop)
                pgenv_debug "PostgreSQL $v not running"
                ;;
            restart)
                pgenv_start_instance
                ;;
        esac
    fi
}

# A function to provide the list, in the right order, of
# patch index files to try for patching the source tree.
# The idea is that the priority goes to an index that matches
# the exact version and the OS-type, then the exact PostgreSQL version,
# and iterates reducing the version to major/minor and finally to
# major only. For example, for the version 8.1.4:
#
#
#  patch/index/patch.8.1.4.Linux
#  patch/index/patch.8.1.4
#  patch/index/patch.8.1.Linux
#  patch/index/patch.8.1
#  patch/index/patch.8.Linux
#  patch/index/patch.8
#
# The first file found must win.
pgenv_patch_get_index_file_names(){
    local version=$1

    local brand=$( echo $version | $PGENV_SED 's/\([[:digit:]]\{1,2\}\).*/\1/' )
    local year=$(  echo $version | $PGENV_SED 's/[[:digit:]]\{1,2\}\.\([[:digit:]]\{1,2\}\).*/\1/' )
    local patch_dir=$PGENV_ROOT/patch/index

    # show all the files in the correct order
    cat <<EOF
$patch_dir/patch.$version.$(uname -s)
$patch_dir/patch.$version
$patch_dir/patch.$brand.$year.$(uname -s)
$patch_dir/patch.$brand.$year
$patch_dir/patch.$brand.$(uname -s)
$patch_dir/patch.$brand
EOF

}

# Utility function to patch a source tree.
# The function accepts a version number, that is the version number of PostgreSQL
# that is going to be built. The function gets the list of available patch index files
# and reads the first one that exists.
# The patch index, in turn, contains a list of patches to be applied in an
# ordered manner.
#
# The second, optional, argument for the function is the "verbose" argument,
# that if not empty, makes the function to print out a message for
# every patch.
pgenv_patch_source_tree() {
    local version=$1
    local verbose=$2
    local current_patch

    # skip all on an empty version
    if [ -z "$version" ]; then
        return
    fi

    # see what index to apply
    if [ -z "$PGENV_PATCH_INDEX" ]; then
        for current_patch in  $( pgenv_patch_get_index_file_names $version )
        do
            if [ -r "$current_patch" ]; then
                PGENV_PATCH_INDEX=$current_patch
                break
            fi
        done
    fi

    pgenv_debug "Patch index file [$PGENV_PATCH_INDEX]"
    if [ ! -r "$PGENV_PATCH_INDEX" ]; then
        # no patch to apply
        pgenv_debug "Skipping patch: no index file found!"
        return
    fi

    # if here, apply all the patches listed in the index file
    for current_patch in $( cat "$PGENV_PATCH_INDEX" )
    do
        # is the current patch file name relative or absolute?
        case "$current_patch" in
            /*) ;;
            *) current_patch="$PGENV_ROOT/patch/$current_patch" ;;
        esac

        if [ -r "$current_patch" ]; then
            pgenv_debug "Applying patch [$current_patch] into source tree $( pwd )"
            $PGENV_PATCH -s -p1 < "$current_patch"

            # if in verbose mode, print out
            # a status message about this patch
            if [ ! -z "$verbose" ]; then
                if [ $? -eq 0 ]; then
                    echo -n "Applied"
                else
                    echo -n "NOT applied"
                fi
                echo " patch $current_patch"
            fi
        fi
    done
}

case $1 in
    use|switch)
        # save the 'command' to check if we should initialize and start the database or not
        command=$1

        v=$( pgenv_guess_postgresql_version $2 $3)
        pgenv_input_version_or_exit "$v" 'show-installed-versions' 'build' 'search_also_on_disk'
        pgenv_installed_version_or_exit $v
        pgenv_configuration_load $v

        # check PATH settings
        pgenv_warning_path

        # Check if current version?
        if [ "`readlink pgsql`" = "pgsql-$v" ]; then
            echo "Already using PostgreSQL $v"
        else
            # Shut down existing running instance.
            if [ -e "pgsql" ]; then
                stopping_version=$( pgenv_current_postgresql_version )
                pgenv_stop_or_restart_instance 'stop' "$stopping_version"
            fi

            # Link the new instance.
            ln -nsf pgsql-$v pgsql
        fi

        # only start the database if the user specified the need to use the database
        if [ "$command" == 'use' ]; then
            # start the instance
	    # (it will automatically initdb if needed)
            pgenv_start_instance
        fi

        exit
        ;;

    start)
        # check a version is currently in use
        pgenv_exit_if_no_postgresql_in_use
        v=$( pgenv_current_postgresql_version )
        pgenv_debug "Current version $v"
        pgenv_configuration_load $v

        # check PATH settings
        pgenv_warning_path

        # Start er up!
        pgenv_start_instance
        exit
        ;;

    stop|restart)
        # check a version is currently in use
        pgenv_exit_if_no_postgresql_in_use
        v=$( pgenv_current_postgresql_version )
        pgenv_debug "Current version $v"
        pgenv_configuration_load $v

        # check PATH settings
        pgenv_warning_path

        # either stop or restart
        command="$1"

        # stop the current instance (or restart it)
        pgenv_stop_or_restart_instance $command "$v"
        exit
        ;;

    status)
        # only proceed when an instance is loaded
        pgenv_exit_if_no_postgresql_in_use
        # print standard postgres status
        $PG_CTL status -s -D "$PG_DATA" | sed -E 's/^pg_ctl:\s+//'
        # instance is either running or stopped at this point
        exit $?
        ;;

    build|rebuild)
        # load executables
        pgenv_check_dependencies

        # save the 'command' so to display it later if the user needs help
        command=$1
        # save the PostgreSQL version to build
        v=$2

        # in the case the version is a special keyword, this
        # must be converted into a build command always, since it
        # does not make sense to `rebuild latest` because
        # the meaning of the special keyword could have been changed
        case $v in
            latest|earliest)
                pgenv_debug "Triggered '$v' $command $current_major"
                command="build"
                current_major="$3"

                # build the hash of the versions
                pgenv_get_downloadable_versions

                if [ -z "$current_major" ]; then
                    # easy: get the first or last index of the hash
                    majors=("${!pg_versions_hash[@]}")

                    if [ "$v" = "latest" ]; then
                        current_major=${majors[-1]}
                    else
                        current_major=${majors[0]}
                    fi
                else
                    # the hash has version number multiplied by 10
                    current_major=$(( current_major * 10 ))
                fi

                # loop thru the array for the selected major version number
                # and extract the first or last position
                for vv in $( echo ${pg_versions_hash[$current_major]} \
                                 | tr '-' '\n'  \
                                 | sort -V )
                do
                    # if earliest stop at the very first iteration
                    if [ "$v" = "earliest" ]; then
                        v=$vv
                        break
                    else
                        v=$vv
                    fi
                done

                pgenv_debug "Selected version to build for '$2 $3' is $v"

        esac

        # sanity checks before building
        pgenv_input_version_or_exit "$v"
        pgenv_configuration_load $v
        pgenv_check_dependencies

        # Skip it if we already have it, and are not rebuilding
        if [ "$command" != 'rebuild' ]; then
            if [ -e "pgsql-$v" ]; then
                echo "PostgreSQL $v already built (did you mean \`rebuild\` instead?)"
                exit 1
            fi
        else
            # rebuild, ensure this is not in use
            if [ "`readlink pgsql`" = "pgsql-$v" ]; then
                echo "PostgreSQL $v in use, prevent rebuilding while in use!"
                exit 1
            fi
        fi

        # Switch to the src directory.
        if [ ! -e "src" ]; then
            mkdir src
        fi
        cd src

        if [ ! -z "$PGENV_LOCAL_POSTGRESQL_REPO" ] && [ -d $PGENV_LOCAL_POSTGRESQL_REPO ]; then
            pgenv_debug "Using local postgresql repo: $PGENV_LOCAL_POSTGRESQL_REPO"
        else
            pgenv_debug "Downloading tarball"

            # Download the source if wee don't already have it.
            # WARNING: older PostgreSQL used .tar.gz instead of .tar.bz2,
            # so if the version is behind 8 use the first format, otherwise
            # try to get the most compressed archive
            if [[ $v =~ ^[1-7]\. ]]; then
                PG_TARBALL="postgresql-$v.tar.gz"
                TAR_OPTS="zxf"
            else
                PG_TARBALL="postgresql-$v.tar.bz2"
                TAR_OPTS="jxf"
            fi

            if [ ! -f $PG_TARBALL ]; then
                $PGENV_CURL -fLO ${PGENV_DOWNLOAD_ROOT}/v$v/${PG_TARBALL}
            fi

            # Starting from 17.x docs target might fail
            # due to a missing dependency (docbooks-xsl).
            # Download the docs tarball separately and
            # install it after build.
            if [[ ${v%.*} -ge 17 ]]; then
                PG_DOCS_TARBALL="postgresql-$v-docs.tar.gz"

                pgenv_debug "Downloading docs tarball"

                if [ ! -f $PG_DOCS_TARBALL ]; then
                    $PGENV_CURL -fLO ${PGENV_DOWNLOAD_ROOT}/v$v/${PG_DOCS_TARBALL}
                fi
            fi
        fi

        # warn if no configuration was loaded
        if [ ! -z "$PGENV_WARNINGS" ]; then
            if [ -z "$PGENV_CONFIGURATION_FILE" ]; then
                seconds=5
                cat <<EOF

WARNING: no configuration file found for version $v
HINT: if you wish to customize the build process please
stop the execution within $seconds seconds (CTRL-c) and run

       pgenv config init $v && pgenv config edit $v

adjust 'configure' and 'make' options and flags and run again

      pgenv $command $v

EOF

                sleep $seconds
            fi
        fi

        rm -rf "postgresql-$v"

        if [ ! -z "$PGENV_LOCAL_POSTGRESQL_REPO" ] && [ -d $PGENV_LOCAL_POSTGRESQL_REPO ]; then
            pgenv_debug "Using local postgresql repo: $PGENV_LOCAL_POSTGRESQL_REPO"

            (cd $PGENV_LOCAL_POSTGRESQL_REPO &&
                 git fetch)
            if [[ $v =~ ^[1-9]\. ]]; then
                # version 1-9
                tag=REL${v}
            else
                tag=REL_${v}
            fi
            tag=${tag^^}        # uppercase for rc, beta, etc
            tag=${tag//./_}     # change dots to underscores

            mkdir postgresql-$v
            (cd $PGENV_LOCAL_POSTGRESQL_REPO &&
                 git archive --format=tar $tag) | tar xp -C postgresql-$v
        else
            pgenv_debug "Unpacking tarball"

            # Unpack the source.
            $PGENV_TAR $TAR_OPTS $PG_TARBALL

            # In order to prevent build failures due to missing
            # dependency for docs since 17.x and above, extracted
            # docs will be placed into the source directory,
            # as if they were built.
            if [[ ${v%.*} -ge 17 ]]; then
                pgenv_debug "Unpacking docs tarball"

                $PGENV_TAR zxf $PG_DOCS_TARBALL
            fi
        fi

        cd postgresql-$v

        # patch the source tree if required
        pgenv_debug "Patching version $v"
        pgenv_patch_source_tree "$v" 'verbose'

        pgenv_debug "configure command line [--prefix=$PGENV_ROOT/pgsql-$v] + [${PGENV_CONFIGURE_OPTIONS[@]}]"
        ./configure --prefix=$PGENV_ROOT/pgsql-$v "${PGENV_CONFIGURE_OPTIONS[@]}"

        # make and make install
        if [[ $v =~ ^[1-8]\. ]]; then
            # 8.x (and prior versions?) doesn't have `make world`.
            $PGENV_MAKE "${PGENV_MAKE_OPTIONS[@]}"
            $PGENV_MAKE install
            cd contrib
            $PGENV_MAKE "${PGENV_MAKE_OPTIONS[@]}"
            $PGENV_MAKE install
        elif [[ ${v%.*} -ge 17 ]]; then
            # Starting from 17.x docs target might fail
            # due to a missing dependency (docbooks-xsl).
            # Build world without docs, then copy prebuilt
            # docs from tarball separately.
            $PGENV_MAKE world-bin "${PGENV_MAKE_OPTIONS[@]}"
            $PGENV_MAKE install-world-bin
            cp -R doc/src/sgml/html $PGENV_ROOT/pgsql-$v/share/doc
        else
            # Yay, make world!
            $PGENV_MAKE world "${PGENV_MAKE_OPTIONS[@]}"
            $PGENV_MAKE install-world
        fi

        # if there is a post-install script to run, run it
        if [ -x "$PGENV_SCRIPT_POSTINSTALL" ]; then
            echo "Running post-install script [$PGENV_SCRIPT_POSTINSTALL]"
            $PGENV_SCRIPT_POSTINSTALL "$v"
        fi

        # write the configuration
        pgenv_configuration_write "$v"

        echo "PostgreSQL $v built"
        exit
        ;;

    clear)
        pgenv_exit_if_no_postgresql_in_use
        v=$( pgenv_current_postgresql_version )
        pgenv_configuration_load $v

        # stop the instance
        pgenv_stop_or_restart_instance 'stop' "$v"

        # We know a version is in use, since pgenv_exit_if_no_postgresql_in_use
        # otherwise would have killed the script.
        rm -f pgsql
        echo "PostgreSQL $v cleared"
        exit
        ;;

    remove)
        v=$( pgenv_guess_postgresql_version "$2" "$3" )
        pgenv_input_version_or_exit "$v" 'show-installed-versions' 'build'

        if [ "`readlink pgsql`" = "pgsql-$v" ]; then
            echo "PostgreSQL $v currently in use"
            echo "Run \`pgenv clear\` to clear it"
            echo "or \`pgenv use\` to switch to another version"
            exit 1
        fi

        rm -fr "pgsql-$v"
        rm -fr src/postgresql-$v.tar.* # could be .tar.bz2 or .tar.gz
        rm -fr src/postgresql-$v
        pgenv_configuration_delete $v  # remove this particular configuration
        pgenv_configuration_delete     # remove default configuration if no instances are left
        echo "PostgreSQL $v removed"
        exit
        ;;

    version|current)
        pgenv_exit_if_no_postgresql_in_use
        pgenv_current_postgresql_version
        exit
        ;;

    versions)
        pgenv_configuration_load
        pgenv_check_dependencies
        pgenv_versions
        exit
        ;;

    help)
        pgenv_help
        exit
        ;;

    available)
        # load executables
        pgenv_check_dependencies

        shift # remove the command from the argument list
        echo -e "             Available PostgreSQL Versions"
        echo -e "========================================================\n"

        # populate the hash of the versions
        pgenv_get_downloadable_versions

        # check to have some version in the hash, or
        # the download did go wrong
        keys=$( echo ${!pg_versions_hash[@]} )
        if [ -z "$keys" ]; then
            echo "No versions found at URL <$PGENV_DOWNLOAD_ROOT>"
            pgenv_debug "Hash content: ${!pg_versions_hash[@]}"
            exit 1
        fi

        # read back the versions and display the output
        # displaying each version with a separated header
        for major in $( echo ${!pg_versions_hash[@]} | sort -n )
        do
            # normalize version numbers
            # (note, use sed instead of bc to avoid introducing another dependency)
            if [ $major -ge 70 -a $major -le 96 ]; then
                current_version=$( echo $major | $PGENV_SED 's/\([[:digit:]]\)\([[:digit:]]\)/\1\.\2/' )
            else
                current_version=$(( major / 10 ))
            fi

            # drop away specific versions if the user required only
            # a few. All arguments, if any, are major version numbers,
            # so check on each of them to see if it makes match with the
            # current version, and if not, avoid printing this version.
            must_print=1 # always print a version group in default
            if [ $# -ge 1 ]; then
                must_print=0
                for required_major in $*
                do
                    if [ $current_version = $required_major ]; then
                        must_print=1
                        break
                    fi
                done

                if [ $must_print -ne 1 ]; then
                    pgenv_debug "Skip major version $current_version (required $*)"
                    continue
                fi
            fi

            echo "                     PostgreSQL $current_version"
            echo "    ------------------------------------------------"
            printed=0
            for numeric in $( echo ${pg_versions_hash[$major]} \
                                  | tr '-' '\n'  \
                                  | sort -V  )
            do
                # new line after 5 numbers
                if [ $printed -gt 5 ]; then
                    printed=0
                    echo
                fi

                # move to right to begin the line
                if [ $printed -eq 0 ]; then
                    echo -n "    "
                fi

                # the output string will be 'MM.m.pp' or 'MM.mm'
                # therefore no more than 6 chars, left aligned
                printf " %-6s " $numeric
                printed=$(( printed +  1 ))
            done
            echo -e "\n"
        done
        exit
        ;;

    check)
        # load default configuration
        pgenv_configuration_load
        # check for all required dependencies
        pgenv_check_dependencies "verbose"

        # check PATH settings
        pgenv_warning_path
        exit
        ;;

    config|configuration)
        action=$2

        if [ -z "$3" ]; then
            v="default"
            nuke=""
        else
            # understand the version the user wants to configure
            v=$( pgenv_guess_postgresql_version $3 $4 )
            if [ "$3" = "default" ]; then
                nuke="default"
            fi
        fi

        # get the currently in use if none specified
        if [ -z "$v"  ]; then
            pgenv_exit_if_no_postgresql_in_use
            v=$( pgenv_current_postgresql_version )
        fi

        title="PostgreSQL version $v"
        configuration_file=$( pgenv_configuration_file_name $v )

        case $action in
            migrate)
                if [ -z "$PGENV_CONFIG_ROOT" ]; then
                    PGENV_CONFIG_ROOT="$PGENV_ROOT/config"
                    echo "No configuration directory set, using [$PGENV_CONFIG_ROOT]"
                fi

                if [ ! -d "$PGENV_CONFIG_ROOT" ]; then
                    mkdir "$PGENV_CONFIG_ROOT"
                fi


                files_migrated=0
                files_missing=0
                files_to_migrate=0
                for old_config_file in "$PGENV_ROOT"/.pgenv.*.conf; do
                    if [ -f "$old_config_file" ]; then
                        files_to_migrate=$(( files_to_migrate + 1 ))
                        new_config_file=$( basename "$old_config_file" | sed 's/\.pgenv\.//' )
                        new_config_file="$PGENV_CONFIG_ROOT/${new_config_file}"
                        pgenv_debug "Migrating [$old_config_file] to [$new_config_file]"
                        mv "$old_config_file" "$new_config_file"
                        if [ $? -eq 0 ]; then
                            files_migrated=$(( files_migrated + 1 ))
                        else
                            files_missing=$(( files_missing + 1 ))
                        fi
                    fi
                done

                if [ $files_to_migrate -eq 0 ]; then
                    echo "No configuration file to migrate!"
                else if [ $files_migrated -gt 0 ]; then
                         echo "Migrated $files_migrated configuration file(s) from previous versions ($files_missing not migrated)"
                         echo "Your configuration file(s) are now into [$PGENV_CONFIG_ROOT]"
                     fi
                fi
                ;;

            show)
                pgenv_configuration_dump_or_exit "$v" "$title" ;;
            init)
                # check that the file does not exist, so
                # that the program does not re-initialize it
                if [ -f "$configuration_file" ]; then
                    pgenv_debug "init $v -> [$configuration_file]"
                    echo "Configuration file [$configuration_file] already exists, cannot re-init it!"
                    exit 1
                fi

                # in an explicit write load first the variables from the runtime
                # environment, so PL/Perl, make, and stuff can be already set
                pgenv_check_dependencies
                pgenv_configuration_write "$v" ;;
            write)
                # load default configuration if exists
                pgenv_configuration_load
                pgenv_configuration_write "$v" ;;
            edit)
                if [ ! -z "$EDITOR" ] && [ $(command -v $EDITOR ) ]; then
                    pgenv_debug "Launching editor $EDITOR"
                    $EDITOR $configuration_file
                else
                    cat <<EOF >&2
No EDITOR variable set (or executable)!
You can either start manually your favourite
editor to edit the configuration file
     $configuration_file
or export the EDITOR variable, such as
     export EDITOR=/path/to/your/editor
and run the command again.
EOF
                    exit 1
                fi
                ;;
            delete)
                pgenv_configuration_delete "$v" "$nuke";;
	    path)
		pgenv_configuration_show_path "$v";;
            *)
                if [ -z "$action" ]; then
                    cat <<EOF >&2
You need to specify one of the following \`config\` actions to perform:

    show
    init
    write
    edit
    delete
    use
    path

For instance:

    pgenv config show <version>

EOF
                else
                    echo "Configuration action \`$action\` not supported"
                fi
                exit 1
                ;;
        esac
        exit
        ;;

    log)
        # get a dump of the logs...but first ensure there is a currently active PostgreSQL instance
        pgenv_exit_if_no_postgresql_in_use

        # extract the current version to display in messages
        v=$( pgenv_current_postgresql_version )
        echo -e "PostgreSQL in use: $v\n"

        shift # remove the command line 'log' argument
        # pass to tail every argument
        if [ -f "$PGENV_LOG" ]; then

            echo -e "Dumping the content of $PGENV_LOG \n"

            # tail is not in a PGENV_ variable, but should have been checked
            # via `pgenv check`
            command tail $* "$PGENV_LOG"
            exit $?
        else
            # uhm.. no log is there, could it be the database
            # has not produced a log at all?
            cat <<EOF
No log to display, is the database logging information?
Please check that the database configuration has logging enabled
and it is logging to

        $PGENV_LOG
EOF
            exit 1
        fi
        ;;

    *)
        if [ $# -gt 0 ]; then
            echo "Unknown command \`$@\`"
        fi

        pgenv_help
        exit 1
        ;;
esac
